# ---------------------------------------------------------
# IOU Tracker
# Copyright (c) 2017 TU Berlin, Communication Systems Group
# Licensed under The MIT License [see LICENSE for details]
# Written by Erik Bochinski
# ---------------------------------------------------------

from py_perception.util import iou


class Tracker:

    def __init__(self, sigma_l, sigma_h, sigma_iou, t_min):
        self.sigma_l = sigma_l
        self.sigma_h = sigma_h
        self.sigma_iou = sigma_iou
        self.t_min = t_min

        self.tracks_active = []
        self.tracks_finished = []

        self.frame_num = 1
        self.next_track_id = 1

    def track_iou(self, detections_frame):
        """
        Simple IOU based tracker.

        Args:
             detections_frame (list): list of detections per frame, usually generated by util.load_mot
        Returns:
            list: list of tracks.
        """
        # Apply low threshold to detections.
        dets = [det for det in detections_frame if det['score'] >= self.sigma_l]

        updated_tracks = []
        for track in self.tracks_active:
            if len(dets) > 0:
                # Get detection with highest iou.
                best_match = max(dets, key=lambda x: iou(track['bboxes'][-1], x['bbox']))

                if iou(track['bboxes'][-1], best_match['bbox']) >= self.sigma_iou:
                    track['bboxes'].append(best_match['bbox'])
                    track['max_score'] = max(track['max_score'], best_match['score'])

                    updated_tracks.append(track)

                    # Remove from best matching detection from detections.
                    del dets[dets.index(best_match)]

            # If track was not updated.
            if len(updated_tracks) == 0 or track is not updated_tracks[-1]:
                # finish track when the conditions are met
                if track['max_score'] >= self.sigma_h and len(track['bboxes']) >= self.t_min:
                    self.tracks_finished.append(track)

        # create new tracks
        new_tracks = []
        for det in dets:
            new_tracks.append(
                {'bboxes': [det['bbox']],
                 'max_score': det['score'],
                 'start_frame': self.frame_num,
                 'track_id': self.next_track_id,
                 'class': det['class']}
            )
            self.next_track_id += 1

        self.tracks_active = updated_tracks + new_tracks

        # finish all remaining active tracks
        self.tracks_finished += [track for track in self.tracks_active
                                 if track['max_score'] >= self.sigma_h and len(track['bboxes']) >= self.t_min]

        # Increment the frame number.
        self.frame_num += 1

        return self.tracks_active

    def get_finished_tracks(self):
        return self.tracks_finished
